//Copyright © 2025, NECTEC, all rights reserved

//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at

//    http://www.apache.org/licenses/LICENSE-2.0

//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

/**
 * @file DataGeneratorModel.hpp
 * @brief Provides manual data generation for testing and constant value injection.
 *
 * This file implements a node that allows users to manually create data of various types
 * through an embedded widget interface. It serves as a data source for testing pipelines,
 * providing constant values, and injecting user-defined parameters into workflows.
 *
 * The DataGenerator is essential for:
 * - Testing: Inject known values to test downstream nodes
 * - Constants: Provide fixed parameters (thresholds, sizes, colors)
 * - Prototyping: Quickly test algorithms without full data sources
 * - Debugging: Replace complex data sources with simple test values
 * - Configuration: User-adjustable parameters without code changes
 *
 * Supported Data Types:
 * 1. Primitive Types:
 *    - Integer (int): Whole numbers (e.g., counts, IDs, thresholds)
 *    - Float (float): Single-precision decimals (e.g., ratios, small measurements)
 *    - Double (double): Double-precision decimals (high-precision calculations)
 *    - Bool (bool): True/false flags (enable/disable features)
 *    - String (std::string): Text data (labels, filenames, messages)
 *
 * 2. OpenCV Types:
 *    - cv::Rect: Rectangular regions (x, y, width, height)
 *    - cv::Point: 2D coordinates (x, y)
 *    - cv::Scalar: 4-element color/value (B, G, R, A or generic 4D vector)
 *
 * The node provides an interactive embedded widget where users can:
 * - Select desired data type from dropdown
 * - Enter value(s) in appropriate input fields
 * - Click "Generate" to output the data
 * - Update values dynamically during runtime
 *
 * Use Cases:
 * - Testing threshold values: Generate Integer → Threshold node
 * - Testing ROI coordinates: Generate cv::Rect → ROI extraction
 * - Color selection: Generate cv::Scalar → Drawing operations
 * - Test points: Generate cv::Point → Geometric calculations
 * - Boolean flags: Generate Bool → Conditional processing
 * - Label text: Generate String → Information display
 *
 * The StringFormat utility class provides advanced string parsing capabilities
 * for placeholder-based text generation, supporting dynamic value insertion
 * into template strings (similar to printf formatting).
 *
 * @see DataGeneratorModel, DataGeneratorEmbeddedWidget, StringFormat
 */

#pragma once

#include <QtCore/QObject>
#include <QtWidgets/QLabel>

#include "DataGeneratorEmbeddedWidget.hpp"
#include "PBNodeDelegateModel.hpp"
#include "CVImageData.hpp"
#include "IntegerData.hpp"
#include "InformationData.hpp"
#include "FloatData.hpp"
#include "DoubleData.hpp"
#include "BoolData.hpp"
#include "StdStringData.hpp"
#include "CVRectData.hpp"
#include "CVPointData.hpp"
#include "CVScalarData.hpp"

using QtNodes::PortType;
using QtNodes::PortIndex;
using QtNodes::NodeData;
using QtNodes::NodeDataType;
using QtNodes::NodeValidationState;

/**
 * @struct GenData
 * @brief Enumeration of data types supported by the DataGenerator.
 *
 * This structure defines all data types that can be manually generated by the user.
 * The enumeration values correspond to indices used in the embedded widget's type selector.
 *
 * Type Mapping:
 * - INVALID (-1): Uninitialized or error state
 * - INT (0): 32-bit signed integer
 * - FLOAT (1): 32-bit floating point
 * - DOUBLE (2): 64-bit floating point
 * - BOOL (3): Boolean true/false
 * - STD_STRING (4): Standard C++ string
 * - CV_RECT (5): OpenCV rectangle (x, y, width, height)
 * - CV_POINT (6): OpenCV 2D point (x, y)
 * - CV_SCALAR (7): OpenCV 4-element vector (typically BGRA color)
 *
 * Each type maps to a corresponding data wrapper class used in the dataflow system
 * (IntegerData, FloatData, DoubleData, BoolData, StdStringData, CVRectData,
 * CVPointData, CVScalarData).
 */
typedef struct GenData
{
    enum GenDataType
    {
        INVALID = -1,      ///< Invalid or uninitialized type
        INT = 0,           ///< Integer type (IntegerData)
        FLOAT = 1,         ///< Float type (FloatData)
        DOUBLE = 2,        ///< Double type (DoubleData)
        BOOL = 3,          ///< Boolean type (BoolData)
        STD_STRING = 4,    ///< String type (StdStringData)
        CV_RECT = 5,       ///< Rectangle type (CVRectData) - x, y, width, height
        CV_POINT = 6,      ///< Point type (CVPointData) - x, y
        CV_SCALAR = 7      ///< Scalar type (CVScalarData) - 4 values (often BGRA)
    };

} GenData;

/**
 * @class DataGeneratorModel
 * @brief Node for manually creating data values of various types through user input.
 *
 * This model provides an interactive data source that allows users to generate values
 * on-demand without needing external files, cameras, or other data sources. It's
 * particularly useful for testing, prototyping, and providing constant parameters to
 * processing pipelines.
 *
 * Functionality Overview:
 * The node presents an embedded widget with:
 * 1. Type Selector: Dropdown to choose data type (INT, FLOAT, RECT, etc.)
 * 2. Value Input Fields: Text boxes or controls for entering values
 *    - Single field for INT, FLOAT, DOUBLE, BOOL, STRING
 *    - Multiple fields for RECT (x, y, w, h), POINT (x, y), SCALAR (4 values)
 * 3. Generate Button: Triggers data output with current values
 *
 * Workflow:
 * ```
 * User selects type (e.g., INT)
 *   ↓
 * User enters value (e.g., "42")
 *   ↓
 * User clicks "Generate" button
 *   ↓
 * em_widget_clicked() called
 *   ↓
 * processData() parses input and creates appropriate data type
 *   ↓
 * Data emitted from output port
 * ```
 *
 * Common Use Cases:
 *
 * 1. Testing Threshold Values:
 *    ```
 *    DataGenerator(INT: 128) → Threshold → Display
 *    ```
 *    Quickly test different threshold values without editing code
 *
 * 2. ROI Coordinates:
 *    ```
 *    DataGenerator(RECT: x=100, y=100, w=200, h=150) → ImageROI → Display
 *    ```
 *    Define region of interest interactively
 *
 * 3. Drawing Color:
 *    ```
 *    DataGenerator(SCALAR: B=0, G=255, R=0, A=255) → DrawCircle
 *    ```
 *    Choose colors for visualization
 *
 * 4. Boolean Flags:
 *    ```
 *    DataGenerator(BOOL: true) → ConditionalNode → Process
 *    ```
 *    Enable/disable features dynamically
 *
 * 5. Test Points for Geometry:
 *    ```
 *    DataGenerator(POINT: x=320, y=240) → DrawMarker → Display
 *    ```
 *    Test geometric operations with known coordinates
 *
 * 6. String Labels:
 *    ```
 *    DataGenerator(STRING: "Test Image") → InformationDisplay
 *    ```
 *    Generate text messages for logging
 *
 * 7. Floating-Point Parameters:
 *    ```
 *    DataGenerator(DOUBLE: 1.5) → ScaleImage → Display
 *    ```
 *    Test scaling factors or other continuous parameters
 *
 * Data Type Details:
 *
 * INT (Integer):
 * - Input: Single text field
 * - Format: "-123" or "456"
 * - Range: -2,147,483,648 to 2,147,483,647
 * - Uses: Counts, indices, pixel values, thresholds
 *
 * FLOAT (Single Precision):
 * - Input: Single text field
 * - Format: "3.14" or "2.5e-3"
 * - Precision: ~7 decimal digits
 * - Uses: Ratios, small measurements, normalized values
 *
 * DOUBLE (Double Precision):
 * - Input: Single text field
 * - Format: "3.141592653589793"
 * - Precision: ~15 decimal digits
 * - Uses: High-precision calculations, coordinates, angles
 *
 * BOOL (Boolean):
 * - Input: Checkbox or "true"/"false" text
 * - Values: true (1) or false (0)
 * - Uses: Feature flags, conditional logic
 *
 * STD_STRING (String):
 * - Input: Multi-line text field
 * - Format: Any UTF-8 text
 * - Uses: Labels, filenames, messages, descriptions
 *
 * CV_RECT (Rectangle):
 * - Input: Four fields (x, y, width, height)
 * - Format: "100, 100, 200, 150"
 * - Constraints: width > 0, height > 0
 * - Uses: ROI specification, bounding boxes
 *
 * CV_POINT (2D Point):
 * - Input: Two fields (x, y)
 * - Format: "320, 240"
 * - Units: Pixels (typically)
 * - Uses: Coordinates, seeds, reference points
 *
 * CV_SCALAR (4-Element Vector):
 * - Input: Four fields (val0, val1, val2, val3)
 * - Format: "255, 0, 0, 255" (Blue in BGRA)
 * - Common Use: Colors (B, G, R, Alpha)
 * - Range: Typically 0-255 for 8-bit color
 *
 * Widget Interaction (em_widget_clicked):
 * When the user clicks "Generate" or triggers output:
 * 1. Widget signals the slot via em_widget_clicked()
 * 2. Slot retrieves current type and value(s) from widget
 * 3. Calls processData() to parse and validate input
 * 4. Creates appropriate data wrapper (IntegerData, FloatData, etc.)
 * 5. Stores in mpInformationData or type-specific member
 * 6. Triggers dataUpdated signal to notify downstream nodes
 *
 * Design Rationale:
 *
 * Why Manual Generation?
 * - Testing: Inject known values without complex setup
 * - Flexibility: Change values during runtime without recompiling
 * - Accessibility: Non-programmers can adjust parameters
 * - Prototyping: Quick experimentation with different values
 *
 * Why Multiple Types?
 * - Type Safety: Ensures downstream nodes receive expected type
 * - Validation: Widget can validate format before sending
 * - Convenience: Appropriate input controls per type (sliders, color pickers, etc.)
 * - Completeness: Covers all common parameter types
 *
 * Why Embedded Widget?
 * - Immediate Access: No separate dialog or property panel needed
 * - Visual Feedback: Clear indication of current values
 * - Graph Integration: Values visible directly in workflow
 * - Quick Updates: Change and regenerate without navigation
 *
 * Advantages:
 * - Interactive parameter tuning without code changes
 * - Supports all common data types used in vision workflows
 * - Visual representation of constant values in graph
 * - No external dependencies (no files, cameras, etc.)
 * - Useful for both development and production debugging
 *
 * Limitations:
 * - Manual input only (no scripting or calculated values)
 * - Single value at a time (no arrays or sequences)
 * - No automatic value ranges or sliders (basic text entry)
 * - Generated value persists until manually changed
 *
 * Best Practices:
 * 1. Use descriptive names when adding to graph ("Threshold Value", "ROI Coords")
 * 2. Document expected ranges in node annotations
 * 3. For production, consider replacing with file-based configuration
 * 4. Validate downstream: add range checks after DataGenerator
 * 5. Use appropriate precision: INT for counts, DOUBLE for angles
 *
 * @see DataGeneratorEmbeddedWidget, GenData, StringFormat
 */
class DataGeneratorModel : public PBNodeDelegateModel
{
    Q_OBJECT

public:
    DataGeneratorModel();

    virtual
    ~DataGeneratorModel() override {}

    QJsonObject
    save() const override;

    void
    load(const QJsonObject &p) override;

    unsigned int
    nPorts(PortType portType) const override;

    NodeDataType
    dataType(PortType portType, PortIndex portIndex) const override;

    std::shared_ptr<NodeData>
    outData(PortIndex port) override;

    void
    setInData(std::shared_ptr<NodeData>, PortIndex) override {};

    /**
     * @brief Returns the embedded data generation widget.
     * @return Pointer to DataGeneratorEmbeddedWidget for user input
     */
    QWidget *
    embeddedWidget() override { return mpEmbeddedWidget; }

    QPixmap
    minPixmap() const override { return _minPixmap; }

    static const QString _category;

    static const QString _model_name;

private Q_SLOTS :

    /**
     * @brief Handles "Generate" button click from embedded widget.
     *
     * This slot is triggered when the user clicks the "Generate" button in the
     * embedded widget. It retrieves the current type and value(s) from the widget,
     * validates and parses the input, then creates the appropriate data object.
     *
     * Workflow:
     * 1. Retrieve selected data type from widget
     * 2. Retrieve input value(s) from text fields
     * 3. Call processData() to parse and create data object
     * 4. Emit dataUpdated signal to trigger downstream processing
     *
     * Example:
     * ```
     * User selects INT, enters "42", clicks Generate
     *   ↓
     * em_widget_clicked() called
     *   ↓
     * processData(INT, "42", output) creates IntegerData(42)
     *   ↓
     * Downstream nodes receive IntegerData
     * ```
     *
     * @note Connected to widget's button clicked signal during construction
     * @see processData, DataGeneratorEmbeddedWidget
     */
    void em_widget_clicked();

private:

    /**
     * @brief Output data (currently stores as InformationData for serialization).
     *
     * Note: Despite the type name, this may be repurposed or the node may maintain
     * separate shared_ptr members for each supported type. The actual output type
     * is determined by the user's selection and returned via outData().
     */
    std::shared_ptr<InformationData> mpInformationData {nullptr};

    DataGeneratorEmbeddedWidget* mpEmbeddedWidget;  ///< Embedded UI for data input

    QPixmap _minPixmap;  ///< Node icon for graph display

    /**
     * @brief Parses user input and creates the appropriate data type.
     *
     * This function takes the user's string input and converts it to the selected
     * data type, performing validation and error handling.
     *
     * Processing by Type:
     *
     * INT:
     * ```cpp
     * int value = std::stoi(input.trimmed());
     * out = std::make_shared<IntegerData>(value);
     * ```
     *
     * FLOAT:
     * ```cpp
     * float value = std::stof(input.trimmed());
     * out = std::make_shared<FloatData>(value);
     * ```
     *
     * DOUBLE:
     * ```cpp
     * double value = std::stod(input.trimmed());
     * out = std::make_shared<DoubleData>(value);
     * ```
     *
     * BOOL:
     * ```cpp
     * bool value = (input.toLower() == "true") || (input == "1");
     * out = std::make_shared<BoolData>(value);
     * ```
     *
     * STD_STRING:
     * ```cpp
     * std::string value = input.toStdString();
     * out = std::make_shared<StdStringData>(value);
     * ```
     *
     * CV_RECT:
     * ```cpp
     * // Parse "x, y, width, height"
     * QStringList parts = input.split(',');
     * int x = parts[0].toInt(), y = parts[1].toInt();
     * int w = parts[2].toInt(), h = parts[3].toInt();
     * out = std::make_shared<CVRectData>(cv::Rect(x, y, w, h));
     * ```
     *
     * CV_POINT:
     * ```cpp
     * // Parse "x, y"
     * QStringList parts = input.split(',');
     * int x = parts[0].toInt(), y = parts[1].toInt();
     * out = std::make_shared<CVPointData>(cv::Point(x, y));
     * ```
     *
     * CV_SCALAR:
     * ```cpp
     * // Parse "v0, v1, v2, v3" (typically B, G, R, A)
     * QStringList parts = input.split(',');
     * double v0 = parts[0].toDouble(), v1 = parts[1].toDouble();
     * double v2 = parts[2].toDouble(), v3 = parts[3].toDouble();
     * out = std::make_shared<CVScalarData>(cv::Scalar(v0, v1, v2, v3));
     * ```
     *
     * Error Handling:
     * - Invalid format: Show error message, set out to nullptr or default value
     * - Out of range: Clamp or reject with error message
     * - Missing fields: Use default values or prompt user
     *
     * @param dataType Type identifier from GenData::GenDataType enum
     * @param input User's input string (from text field)
     * @param out Output shared_ptr to created data object
     *
     * @note Performs trimming and basic validation on input
     * @note May throw or return error status for invalid input
     */
    void processData(const int& dataType, const QString& input,
                     std::shared_ptr<InformationData> &out);
};

/**
 * @class StringFormat
 * @brief Utility class for parsing strings with placeholders and pattern matching.
 *
 * This class provides advanced string manipulation capabilities for template-based
 * text generation, similar to printf-style formatting but with more flexible placeholder
 * syntax. It's designed to support dynamic string generation where values can be inserted
 * into predefined templates.
 *
 * Primary Features:
 * 1. Placeholder Detection: Identify and count placeholders in template strings
 * 2. String Splitting: Break strings at placeholder boundaries or custom delimiters
 * 3. Pattern Matching: Extract values matching placeholder patterns
 * 4. Whitespace Compression: Normalize spacing in text
 *
 * Use Cases:
 * - Generate formatted messages: "Frame {0}: Detected {1} objects"
 * - Parse structured text: Extract values from known formats
 * - Template-based string building: Fill templates with runtime data
 * - Log message formatting: Consistent log entry structure
 *
 * The Placeholder sub-structure defines supported placeholder types and matching patterns
 * used throughout the string manipulation operations.
 */
class StringFormat
{
public :

    /**
     * @struct Placeholder
     * @brief Defines placeholder syntax and types for template string processing.
     *
     * This structure specifies the placeholder patterns recognized by StringFormat,
     * enabling template-based string generation with type-specific value insertion.
     *
     * Placeholder Syntax:
     * - placeholder_str: String placeholder pattern (e.g., "{s}" or "%s")
     * - placeholder_int: Integer placeholder pattern (e.g., "{d}" or "%d")
     * - placeholders: Vector of all supported placeholder strings
     * - placeholder_match: Regex pattern for matching any placeholder
     *
     * Example Usage:
     * Template: "Detected {d} faces at {s}"
     * Values: [5, "14:32:15"]
     * Result: "Detected 5 faces at 14:32:15"
     *
     * The PlaceholderKey enum allows querying specific placeholder types or all types:
     * - ALL: Count/match all placeholders regardless of type
     * - STD_STRING: Only string placeholders
     * - INT: Only integer placeholders
     */
    typedef struct Placeholder //define str and enum of a placeholder here
    {

        static const std::string placeholder_str;     ///< String placeholder pattern
        static const std::string placeholder_int;     ///< Integer placeholder pattern

        static const std::vector<std::string> placeholders;  ///< All placeholder patterns

        static const std::string placeholder_match;   ///< Regex pattern for matching placeholders

        /**
         * @enum PlaceholderKey
         * @brief Enumeration for placeholder type filtering.
         */
        enum PlaceholderKey
        {
            ALL = 0,         ///< All placeholder types
            STD_STRING = 1,  ///< String placeholders only
            INT = 2          ///< Integer placeholders only
        };

    } Placeholder;

private :

    std::string format;  ///< Template string with placeholders

public :

    /**
     * @brief Default constructor with empty format string.
     */
    StringFormat()
        : format(std::string())
    {
    }

    /**
     * @brief Constructor with format string initialization.
     * @param f Template string containing placeholders
     */
    StringFormat(const std::string f)
        : format(f)
    {
    }

    ~StringFormat() = default;

    /**
     * @brief Count placeholders of a specific type in the format string.
     *
     * Scans the template string and counts occurrences of placeholders matching
     * the specified type.
     *
     * @param type Placeholder type to count (ALL, STD_STRING, or INT)
     * @return Number of placeholders found
     *
     * Example:
     * ```cpp
     * StringFormat fmt("Name: {s}, Count: {d}, Time: {s}");
     * fmt.placeholder_count(Placeholder::STD_STRING);  // Returns 2
     * fmt.placeholder_count(Placeholder::INT);         // Returns 1
     * fmt.placeholder_count(Placeholder::ALL);         // Returns 3
     * ```
     */
    int placeholder_count(const Placeholder::PlaceholderKey type) const;

    /**
     * @brief Remove extra whitespace from text (compress consecutive spaces to one).
     *
     * Normalizes whitespace by replacing multiple consecutive spaces, tabs, or
     * newlines with a single space.
     *
     * @param text Input text with potentially redundant whitespace
     * @return Compressed text with normalized spacing
     *
     * Example:
     * ```cpp
     * compress("Hello    world  \t\n  test")  → "Hello world test"
     * ```
     */
    std::string compress(std::string text) const;
    
    /**
     * @brief In-place version of whitespace compression.
     * @param text Pointer to string to compress (modified in-place)
     */
    void compress(std::string* text) const;

    /**
     * @brief Split text by a single delimiter key.
     *
     * Breaks the input text into segments separated by the specified key string.
     *
     * @param text Input text to split
     * @param key Delimiter string
     * @return Vector of text segments (excluding delimiters)
     *
     * Example:
     * ```cpp
     * split("apple,banana,cherry", ",")  → ["apple", "banana", "cherry"]
     * ```
     */
    std::vector<std::string> split(const std::string& text, const std::string key) const;
    
    /**
     * @brief In-place version of single-key split.
     * @param text Input text to split
     * @param splitText Output vector to fill with segments
     * @param key Delimiter string
     */
    void split(const std::string& text, std::vector<std::string>& splitText, const std::string key) const;
    
    /**
     * @brief Split text by multiple delimiter keys.
     *
     * Breaks text at any occurrence of any delimiter in the keyList.
     *
     * @param text Input text to split
     * @param keyList Vector of delimiter strings
     * @return Vector of text segments
     *
     * Example:
     * ```cpp
     * split("a,b;c:d", {",", ";", ":"})  → ["a", "b", "c", "d"]
     * ```
     */
    std::vector<std::string> split(const std::string& text, const std::vector<std::string> keyList) const;
    
    /**
     * @brief In-place version of multi-key split.
     * @param text Input text to split
     * @param splitText Output vector to fill with segments
     * @param keyList Vector of delimiter strings
     */
    void split(const std::string& text, std::vector<std::string>& splitText, const std::vector<std::string> keyList) const;

    /**
     * @brief Extract values matching placeholder positions in the format string.
     *
     * Compares the input text against the format template and extracts values
     * at placeholder positions. Useful for parsing structured text.
     *
     * @param text Input text to parse
     * @param ignore_gaps If true, allows extra text between matched sections
     * @return Vector of extracted values (as strings)
     *
     * Example:
     * ```cpp
     * StringFormat fmt("Frame {d}: Status {s}");
     * fmt.match("Frame 42: Status OK")  → ["42", "OK"]
     * ```
     *
     * @note Returns empty vector if text doesn't match format structure
     */
    std::vector<std::string> match(std::string text, const bool ignore_gaps = false) const;
    
    /**
     * @brief In-place version of pattern matching.
     * @param text Input text to parse
     * @param matched Output vector to fill with extracted values
     * @param ignore_gaps Allow flexible matching with gaps
     */
    void match(std::string text, std::vector<std::string>& matched, const bool ignore_gaps = false) const;

};

